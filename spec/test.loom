require "loomext/all"

desc "Prints some known facts"
pattern :three_facts do |loom, facts|
  puts "first 3 facts..."
  puts facts.facts.to_a.slice(0, 3).map { |tuple| tuple.join "=" }.join("\n")
end

desc "Reports `uptime` status"
pattern :uptime do |loom, facts|
  loom << :uptime
  loom << :hostname
  loom.local << :hostname
end

desc "cd's to the /etc directory and runs `pwd`"
pattern :cd do |loom, facts|
  loom.cd "/etc" do
    loom << :pwd
  end
end

desc "tests return codes from wrapped commands"
pattern :wrap_returns do |loom, facts|
  # using loom.time as a proxy for Shell::Core#wrap here
  loom.time do
    raise "wrapped true is not true" unless loom.test :true
    raise "wrapped false is not false" if loom.test :false
  end
end

desc "Tests a condition."
pattern :test do |loom, facts|
  unless loom.test :false
    loom.x :echo, "i tested false"
  end

  if loom.test :true
    loom.x :echo, "i tested true"
  end

  if loom.test :which, "bash"
    loom.x :echo, "has bash"
  end
end

desc "Tests a grep condition."
pattern :match do |loom, facts|
  if loom.files("/etc/hosts").match? :pattern => "aldsfja;ldjf"
    loom.fail "should not match garbage"
  else
    loom.x :echo, "I didnt match garbage"
  end

  unless loom.files("/etc/hosts").match? :pattern => "localhost"
    loom.fail "should match localhost"
  else
    loom.x :echo, "I did match my target"
  end
end

desc "Always fails due to return code."
pattern :fail_soft do |loom, facts|
  unless loom << :false
    loom.x :echo, "i am false"
  end
end

desc "Always fails due to a hard failure"
pattern :fail_hard do |loom, facts|
  loom.fail "Fail big or not at all"
end

desc "Check timeout commands"
pattern :timeout_fail do |loom, facts|
  loom.timeout(:timeout => 1) do
    loom.x :sleep, 2
  end
end

desc "Wrapped time commands"
pattern :time do |loom, facts|
  loom.time do
    loom.x :echo, :hi
    loom.x :sleep, 2
  end
end

module Net
  include Loom::Pattern

  desc "tests the net package, with_net check"
  pattern :check_net do |loom, facts|
    unless loom.net(check_host: '127.0.0.1').has_net?
      loom.fail 'can not ping localhost'
    end

    has_local_net = false
    loom.net(check_host: '127.0.0.1').with_net do
      has_local_net = true
    end
    loom.fail "should have local net" unless has_local_net
  end

  desc "expected check_net failures"
  pattern :check_net_fail do |loom, facts|
    loom.net(timeout: 2, check_host: '1.1.1.1').check_net
  end
end

module Files
  include Loom::Pattern

  desc "Reads a file"
  pattern :read do |loom, facts|
    loom.files("/etc/hosts").cat
  end

  desc "Gsubs file text"
  pattern :gsub do |loom, facts|
    loom.files("/tmp/garbage").write <<EOS
This is a bunch of junk
192.123.456.0\t\thostname.xyz
EOS

    loom.files("/tmp/garbage")
      .cat
      .gsub(pattern: /[\d]{3}/, replace: "xxx")
      .append("this is something new")
      .cat
  end

  desc "Chowns a file"
  pattern :chown do |loom, facts|
    loom.files("/tmp/chown.me")
      .touch
      .append("this file will be owned by root")

    loom.sudo do
      loom.files("/tmp/chown.me").chown user: :root
      loom.x :ls, "-lZ", "/tmp/chown.me"

      loom.files("/tmp/chown.me").chown user: :root, group: :root
    end

    loom.sudo { loom.exec :rm, "/tmp/chown.me" }
  end
end

module Shell
  include Loom::Pattern

  desc "Executes some commands in a subshell"
  pattern :subshell do |loom, facts|
    loom << :"(echo $$; echo $BASHPID; whoami)"
    loom << :"(sudo -i -u root whoami)"

    loom.local << :"(echo $$; echo $BASHPID; whoami)"
    #    loom.local << "(sudo -i -u root whoami)"
  end

  desc "Tests nested sudo scenarios"
  pattern :sudo do |loom, facts|
    loom.sudo user: "root" do
      loom << :pwd
      loom << :whoami
      loom.exec :touch, "loom.file"

      loom.sudo do
        loom << :whoami
        loom << :pwd
        loom.x :touch, "root.file"

        loom.user.add_system_user :postgres, uid: 999
        loom.sudo user: :postgres do
          loom << :whoami
          loom.cd "/tmp" do
            loom << :pwd
            loom.x :touch, "postgres.file"
          end
        end
        loom.user.remove :postgres

        loom.x :touch, "root.file2"
      end
    end

    loom.cd "/tmp" do
      loom << :pwd
      loom.sudo user: :root, cmd: :pwd do loom << :pwd end
      loom << :pwd
    end

  end
end

module Parent
  include Loom::Pattern

  with_facts :outer_fact => :outer, :replaced => :original

  before do
    puts "Test::Parent => before"
  end

  after do
    puts "Test::Parent => after"
  end

  desc "Checks facts on a parent pattern"
  pattern :check_facts do |loom, facts|
    unless facts[:outer_fact] == :outer
      raise "expected outer fact => #{facts[:outer_fact]}"
    end
  end

  let(:a_let_key) { "the value" }
  let(:a_fact_based_let) { |facts| facts[:outer_fact].to_s + "/let" }
  let(:a_referencing_let) { a_let_key + " referenced" }

  desc "Checks let defines"
  pattern :check_lets do |loom, facts|
    raise "bad let :a_let_key" unless a_let_key == "the value"
    raise "bad let :a_fact_based_let" unless a_fact_based_let == "outer/let"

    unless a_referencing_let == "the value referenced"
      raise "bad let :a_referencing_let => #{a_referencing_let}"
    end

    puts "a_let_key: %s" % a_let_key
    puts "a_fact_based_let: %s" % a_fact_based_let
  end

  module Child
    include Loom::Pattern

    with_facts :inner_fact => :inner, :replaced => :override
    let(:a_let_key) { |facts|  facts[:inner_fact].to_s + " overrides parent" }

    before do
      puts "Test::Parent::Child => before"
    end

    after do
      puts "Test::Parent::Child => after"
    end

    desc "Check let overrides"
    pattern :check_let_overrides do |loom, facts|
      raise "bad let :a_let_key" unless a_let_key == "inner overrides parent"
      raise "bad let :a_fact_based_let" unless a_fact_based_let == "outer/let"

      puts "child a_let_key: %s" % a_let_key
      puts "child a_fact_based_let: %s" % a_fact_based_let
    end

    desc "Checks inherited facts on a cihld pattern"
    pattern :check_facts do |loom, facts|
      unless facts[:inner_fact] == :inner
        raise "expected inner fact => #{facts[:inner_fact]}"
      end
      unless facts[:outer_fact] == :outer
        raise "expected outer fact => #{facts[:outer_fact]}"
      end
      unless facts[:replaced] == :override
        raise "expected replaced fact => #{facts[:replaced_fact]}"
      end
    end
  end
end

module User
  include Loom::Pattern

  desc "Adds a bunch of users and then removes them right away"
  pattern :add_users do |loom, facts|
    loom.sudo do
      loom.user.add :nara, uid: 1001, home_dir: "/home/nara"
      loom.user.add :marrian, home_dir: "/home/marrian"

      loom.user.add_system_user :app, uid: 900
      loom.user.add_system_user :batch

      loom.user.remove :nara
      loom.user.remove :marrian
      loom.user.remove :app
      loom.user.remove :batch
    end
  end

  desc "Makes the postgres user a sudoer"
  pattern :sudoers do |loom, facts|
    loom.sudo do
      loom.user.add_system_user :postgres, uid: 999
      loom.user.make_sudoer :postgres
      loom.user.remove :postgres
    end
  end
end

module Package
  include Loom::Pattern

  namespace :pkg

  before do |loom, facts|
    puts "#{self} in before"
  end

  after do
    puts "#{self} in after"
  end

  desc "Updates the default package manager cache"
  pattern :update_cache do |loom, facts|
    loom.sudo { loom.pkg.update_cache }
  end

  desc "Installs Apache HTTP server"
  pattern :install_httpd do |loom, facts|
    loom.sudo do
      loom.pkg.install 'apache2' unless loom.pkg.installed? 'apache2'
    end
  end

  desc "Installs Facter GEM"
  pattern :install_facter do |loom, facts|
    loom.sudo do
      loom.pkg[:gem].ensure_installed :facter
    end
  end
end

module ErrorHandling
  include Loom::Pattern

  namespace :err

  desc "Handle SSH disconnection errors"
  pattern :ssh_disconnect do |loom, facts|
    if facts[:really_really_reboot]
      loom.sudo cmd: :reboot
    else
      puts "to REALLY reboot set fact[:really_really_reboot] = true"
    end
  end
end

module VMs
  include Loom::Pattern

  desc "Check if some virtualbox vms exist"
  pattern :vm_exists? do |loom, facts|
    vm0_exists = loom.local.vbox.check_exists "vm0.local"
    puts "Virtualbox VM 'vm0.local' exists: #{vm0_exists}"
  end

  desc "Check if some virtualbox vms exist"
  pattern :list do |loom, facts|
    loom.local.vbox.list
  end

  desc "Takes a snapshot of a VM"
  pattern :snap do |loom, facts|
    loom.local.vbox.snapshot "vm0.local", snapshot_name: "test:snap"
    loom.local.vbox.snapshot "vm0.local", action: :delete, snapshot_name: "test:snap"
  end
end
